---
title: "Homework_10"
author: "Gavin Briske"
date: "5/20/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(ggplot2)
library(broom)
library(HH)
library(GGally)
```


```{r}

counter<-0

count<-function(n, size, prob){
  
x<-rbinom(n = n, size = size, prob = prob)

for(i in 1:n){
  if (x[i]==0) {
    counter<-counter+1
  }
}
return(counter)
}

count(6000, 2, .4)
```

 
 
 
```{r}

counter2<-0

count2<-function(n, size, p){
  x<-rbinom(n = n, size = size, p = p)
 counter<-NROW(x[which(x[1:n]==0)])
 return(counter)
}

count2(1000, 2, .9)
```


```{r}
mxprod <-function(row, col){
m<-matrix(nrow = row, ncol=col)
for(i in 1:row){
  for(j in 1:col){
    m[i,j]<-i*j
  }
}
return(m)
}

mxprod(3, 4)
```

```{r}

set.seed(123)

myData<-iris[,1:2]
myData$ID<-seq(1:150)
names(myData)<-c("xObs", "yObs", "ID")

z<-myData

#Set up functions

##################################################
# function: getMetric
# calculate metric for randomization test
# input: 2-column data frame for regression
# output: regression slope
#------------------------------------------------- 
getMetric <- function(z=myData) {
  if(is.null(z)){
    xObs <- 1:20
    yObs <-  xObs + 10*rnorm(20)
    z <- data.frame(ID=seq_along(xObs),xObs,yObs)} # set up data frame                 
  . <- lm(z[,3]~z[,2])
  . <- summary(.)
  . <- .$coefficients[2,1]
  
  slope <- .
  return(slope)
}


##################################################
# function: shuffleData
# randomize data for regression analysis
# input: 3-column data frame (ID,xVar,yVar)
# output: 3-column data frame (ID,xVar,yVar)
#------------------------------------------------- 
shuffleData <- function(z) {
  if(is.null(z)){
    xObs <- 1:20
    yObs <- xObs + 3*rnorm(20)
    z <- data.frame(ID=seq_along(xObs),xObs,yObs)} # set up data frame                 
  z[,3] <- sample(z[,3]) # use sample function with defaults to reshuffle column
  
  return(z)
}

##################################################
# function: getPVal
# calculate p value from simulation
# input: list of observed metric, and vector of simulated metrics
# output: lower, upper tail probability values
#------------------------------------------------- 
getPVal <- function(z) {
  if(is.null(z)){
    z <- list(xObs=runif(1),xSim=runif(1000))}
  pLower <- mean(z[[2]]<=z[[1]])
  pUpper <- mean(z[[2]]>=z[[1]])
  return(c(pL=pLower,pU=pUpper))
}


#First get means of data 

##################################################
# function: plotRanTest
# create ggplot of histogram of simulated values
# input: list of observed metric and vector of simulated metrics
# output: saved ggplot graph
#------------------------------------------------- 
plotRanTest <- function(z=myData) {
  if(is.null(z)){
    z <- list(rnorm(1),rnorm(1000)) }
  
  dF <- data.frame(ID=seq_along(z[[2]]),simX=z[[2]])
  p1 <- ggplot(data=dF,mapping=aes(x=simX))
  p1 + geom_histogram(mapping=aes(fill=I("goldenrod"),color=I("black"))) +
    geom_vline(aes(xintercept=z[[1]],col="blue")) 
  
}
set.seed(1000)
nSim <- 1000
Xsim <- rep(NA,nSim) # vector of simulated slopes
Xobs <- getMetric()


for (i in seq_len(nSim)) {
  Xsim[i] <- getMetric(shuffleData(myData))
}

slopes <- list(Xobs,Xsim)

getPVal(slopes)
```


```{r}
myData<-iris[,1:2]
myData$ID<-seq(1:150)
names(myData)<-c("xObs", "yObs", "ID")


getMetric(z=myData)
shuffleData(myData)
getPVal(myData)
plotRanTest(myData)


#compare to regular lm
lm1<-lm(myData$yObs ~ myData$xObs)
plot(lm1)
summary(lm(myData$yObs ~ myData$xObs))
```
P-values seem to be higher with simulated data compared to the lm function. 

